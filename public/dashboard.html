<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>xcomponent-ai Dashboard</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <style>
    /* Reset & Base */
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg-primary: #0f0f0f;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #252525;
      --glass-bg: rgba(255, 255, 255, 0.08);
      --glass-border: rgba(255, 255, 255, 0.15);
      --text-primary: #f0f0f0;
      --text-secondary: rgba(255, 255, 255, 0.7);
      --text-muted: rgba(255, 255, 255, 0.5);
      --accent: #fbbf24;
      --accent-hover: #f59e0b;
      --success: #10b981;
      --error: #ef4444;
      --info: #3b82f6;
      --inter-machine: #10b981;
      --sidebar-width: 320px;
      --header-height: 70px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg-primary);
      min-height: 100vh;
      color: var(--text-primary);
      overflow: hidden;
    }

    /* Main Layout */
    .app-layout {
      display: grid;
      grid-template-columns: var(--sidebar-width) 1fr;
      grid-template-rows: var(--header-height) 1fr;
      height: 100vh;
      gap: 1px;
      background: var(--glass-border);
    }

    /* Header */
    .header {
      grid-column: 1 / -1;
      background: var(--bg-secondary);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      border-bottom: 1px solid var(--glass-border);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .logo {
      font-size: 22px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .logo span {
      color: var(--accent);
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--error);
    }

    .status-dot.connected {
      background: var(--success);
      box-shadow: 0 0 10px var(--success);
    }

    .header-stats {
      display: flex;
      gap: 24px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-value {
      font-size: 20px;
      font-weight: 700;
      color: var(--accent);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Sidebar */
    .sidebar {
      background: var(--bg-secondary);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-section {
      padding: 16px;
      border-bottom: 1px solid var(--glass-border);
    }

    .sidebar-section.flex {
      flex: 1;
      overflow-y: auto;
    }

    .section-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      margin-bottom: 12px;
    }

    .selector {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
      cursor: pointer;
      outline: none;
    }

    .selector:focus {
      border-color: var(--accent);
    }

    /* Instance List */
    .instance-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .instance-item {
      padding: 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .instance-item:hover {
      background: rgba(251, 191, 36, 0.1);
      border-color: var(--accent);
    }

    .instance-item.selected {
      background: rgba(251, 191, 36, 0.15);
      border-color: var(--accent);
    }

    .instance-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .instance-machine {
      font-size: 13px;
      font-weight: 600;
      color: var(--accent);
    }

    .instance-id {
      font-size: 11px;
      color: var(--text-muted);
      font-family: monospace;
    }

    .instance-state {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .entry-badge {
      display: inline-block;
      padding: 2px 6px;
      background: rgba(251, 191, 36, 0.2);
      color: var(--accent);
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      margin-left: 6px;
    }

    /* Main Content */
    .main-content {
      background: var(--bg-secondary);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Component Overview */
    .component-overview {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .overview-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .overview-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .overview-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .view-mode-btn {
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .view-mode-btn:hover {
      background: var(--glass-bg);
      border-color: var(--accent);
      color: var(--accent);
    }

    .view-mode-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #000;
      font-weight: 600;
    }

    .overview-legend {
      display: flex;
      gap: 20px;
      font-size: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-box {
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }

    .legend-box.entry {
      background: var(--accent);
    }

    .legend-box.terminal {
      background: var(--success);
    }

    .legend-line {
      width: 24px;
      height: 3px;
    }

    .legend-line.inter-machine {
      background: var(--success);
    }

    /* Component Graph */
    .component-graph {
      flex: 1;
      padding: 24px;
      overflow: auto;
      position: relative;
    }

    /* Diagram Grid Mode */
    .diagram-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 24px;
      padding: 20px;
    }

    .diagram-card {
      background: var(--bg-tertiary);
      border: 2px solid var(--glass-border);
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s;
    }

    .diagram-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    }

    .diagram-card.entry-machine {
      border-color: var(--accent);
      background: rgba(251, 191, 36, 0.05);
    }

    .diagram-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--glass-border);
    }

    .diagram-card-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .diagram-card-content {
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 16px;
      min-height: 300px;
      overflow: auto;
    }

    .machine-card {
      position: absolute;
      background: var(--bg-tertiary);
      border: 2px solid var(--glass-border);
      border-radius: 12px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .machine-card:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    }

    .machine-card.entry-machine {
      border-color: var(--accent);
      background: rgba(251, 191, 36, 0.1);
    }

    .machine-card.selected {
      border-color: var(--info);
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
    }

    .machine-card-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
    }

    .machine-card-name {
      font-size: 15px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .entry-star {
      color: var(--accent);
      font-size: 14px;
    }

    .machine-card-info {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: var(--text-secondary);
    }

    .info-row {
      display: flex;
      justify-content: space-between;
    }

    .info-label {
      color: var(--text-muted);
    }

    .instance-badge {
      display: inline-block;
      padding: 2px 8px;
      background: rgba(59, 130, 246, 0.2);
      color: var(--info);
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }

    /* Machine Detail View */
    .machine-detail {
      flex: 1;
      display: none;
      flex-direction: column;
      overflow: hidden;
    }

    .machine-detail.active {
      display: flex;
    }

    .detail-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--glass-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .detail-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .back-btn {
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      color: var(--text-secondary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .back-btn:hover {
      background: var(--glass-bg);
      border-color: var(--accent);
      color: var(--accent);
    }

    .detail-content {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 1px;
      background: var(--glass-border);
      overflow: hidden;
    }

    .diagram-section {
      background: var(--bg-secondary);
      padding: 24px;
      overflow: auto;
    }

    .diagram-container {
      background: var(--bg-primary);
      border-radius: 12px;
      padding: 24px;
      min-height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: auto;
    }

    /* Make Mermaid SVG responsive */
    .diagram-container .mermaid,
    .diagram-card-content .mermaid {
      width: 100%;
      overflow: visible;
    }

    .diagram-container .mermaid svg,
    .diagram-card-content .mermaid svg {
      max-width: 100%;
      height: auto !important;
    }

    .transitions-section {
      background: var(--bg-secondary);
      padding: 20px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .transitions-header {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .transition-item {
      padding: 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .transition-item:hover {
      background: rgba(59, 130, 246, 0.1);
      border-color: var(--info);
    }

    .transition-item.inter-machine {
      border-color: var(--inter-machine);
      background: rgba(16, 185, 129, 0.05);
    }

    .transition-item.inter-machine:hover {
      background: rgba(16, 185, 129, 0.15);
    }

    .transition-info {
      margin-bottom: 10px;
    }

    .transition-event {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 4px;
    }

    .transition-path {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .transition-target {
      font-size: 11px;
      color: var(--inter-machine);
      margin-top: 4px;
    }

    .transition-send-btn {
      width: 100%;
      padding: 8px;
      background: var(--info);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .transition-send-btn:hover {
      background: #2563eb;
      transform: translateY(-1px);
    }

    .transition-item.inter-machine .transition-send-btn {
      background: var(--inter-machine);
    }

    .transition-item.inter-machine .transition-send-btn:hover {
      background: #059669;
    }

    /* Empty States */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-muted);
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 15px;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 24px;
      right: 24px;
      padding: 16px 24px;
      background: var(--bg-tertiary);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      font-size: 14px;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s;
      z-index: 1000;
    }

    .toast.show {
      transform: translateY(0);
      opacity: 1;
    }

    .toast.success {
      border-color: var(--success);
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .toast.error {
      border-color: var(--error);
      background: rgba(239, 68, 68, 0.1);
      color: var(--error);
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--glass-bg);
    }

    /* Pulse animation for urgent countdowns */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div class="app-layout">
    <!-- Header -->
    <div class="header">
      <div class="header-left">
        <div class="logo">xcomponent<span>.ai</span></div>
        <div class="connection-status">
          <div class="status-dot" id="status-dot"></div>
          <span id="status-text">Connecting...</span>
        </div>
      </div>
      <div class="header-stats">
        <div class="stat-item">
          <div class="stat-value" id="stat-components">0</div>
          <div class="stat-label">Components</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-machines">0</div>
          <div class="stat-label">Machines</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-instances">0</div>
          <div class="stat-label">Instances</div>
        </div>
      </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <!-- Component Selector -->
      <div class="sidebar-section">
        <div class="section-title">Component</div>
        <select class="selector" id="component-select" onchange="selectComponent()">
          <option value="">Select a component...</option>
        </select>
      </div>

      <!-- Instances -->
      <div class="sidebar-section flex">
        <div class="section-title">Instances <span id="instance-count" style="color: var(--text-muted); font-weight: normal;"></span></div>
        <!-- Search filter for instances -->
        <input type="text" id="instance-filter" placeholder="Filter by ID, state, or data..."
          style="width: 100%; padding: 8px 10px; margin-bottom: 12px; background: var(--bg-tertiary); border: 1px solid var(--glass-border); border-radius: 6px; color: var(--text-primary); font-size: 12px;"
          oninput="renderInstanceList()">
        <div class="instance-list" id="instance-list">
          <div class="empty-state" style="padding: 40px 20px;">
            <div class="empty-state-icon">üì¶</div>
            <div style="font-size: 12px;">No instances</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Component Overview -->
      <div class="component-overview" id="component-overview">
        <div class="overview-header">
          <div class="overview-title" id="overview-title">Component Overview</div>
          <div class="overview-controls">
            <button class="view-mode-btn" id="btn-cards" onclick="setOverviewMode('cards')">üìä Cards</button>
            <button class="view-mode-btn active" id="btn-diagrams" onclick="setOverviewMode('diagrams')">üìà Diagrams</button>
            <div class="overview-legend">
              <div class="legend-item">
                <div class="legend-box entry"></div>
                <span>Entry Point</span>
              </div>
              <div class="legend-item">
                <div class="legend-box terminal"></div>
                <span>Terminal State</span>
              </div>
              <div class="legend-item">
                <div class="legend-line inter-machine"></div>
                <span>Inter-machine Transition</span>
              </div>
            </div>
          </div>
        </div>
        <div class="component-graph" id="component-graph">
          <div class="empty-state">
            <div class="empty-state-icon">üé®</div>
            <div>Select a component to view its state machines</div>
          </div>
        </div>
      </div>

      <!-- Machine Detail View -->
      <div class="machine-detail" id="machine-detail">
        <div class="detail-header">
          <div class="detail-title" id="detail-title">Machine Detail</div>
          <button class="back-btn" onclick="backToOverview()">‚Üê Back to Overview</button>
        </div>
        <div class="detail-content">
          <div class="diagram-section">
            <div class="diagram-container" id="diagram-container">
              <div class="empty-state">
                <div class="empty-state-icon">üìä</div>
                <div>Select a machine to view its diagram</div>
              </div>
            </div>
          </div>
          <div class="transitions-section">
            <!-- Instance Context/PublicMember -->
            <div id="instance-context-section" style="margin-bottom: 16px;">
              <div class="transitions-header">üì¶ Instance Data</div>
              <div id="instance-context" style="padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-top: 8px;">
                <div style="font-size: 12px; color: #666;">Select an instance to see its data</div>
              </div>
            </div>

            <!-- Instance History/Traceability -->
            <div id="instance-history-section" style="margin-bottom: 16px;">
              <div class="transitions-header">üìú Event History</div>
              <div id="instance-history" style="padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; margin-top: 8px; max-height: 300px; overflow-y: auto;">
                <div style="font-size: 12px; color: #666;">Select an instance to see its history</div>
              </div>
            </div>

            <div class="transitions-header">‚ö° Quick Actions</div>
            <div id="transitions-list">
              <div class="empty-state" style="padding: 20px 0;">
                <div style="font-size: 12px;">Select an instance to see available actions</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <script>
    // Initialize Mermaid
    mermaid.initialize({
      startOnLoad: false,
      theme: 'dark',
      themeVariables: {
        darkMode: true,
        background: '#0f0f0f',
        primaryColor: '#fbbf24',
        primaryTextColor: '#f0f0f0',
        primaryBorderColor: '#f59e0b',
        lineColor: '#666',
        secondaryColor: '#10b981',
        tertiaryColor: '#3b82f6'
      }
    });

    // State
    let socket = null;
    let componentsData = [];
    let selectedComponentName = null;
    let selectedMachineName = null;
    let selectedInstanceId = null;
    let allInstances = [];
    let currentTransitions = [];
    let overviewMode = 'diagrams'; // 'cards' or 'diagrams' - default to diagrams

    // Format milliseconds as human-readable time (used by multiple functions)
    function formatTimeRemaining(ms) {
      if (ms <= 0) return 'Expired';
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) return `${days}d ${hours % 24}h`;
      if (hours > 0) return `${hours}h ${minutes % 60}m`;
      if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
      return `${seconds}s`;
    }

    // Socket.IO connection
    socket = io();

    socket.on('connect', () => {
      document.getElementById('status-dot').classList.add('connected');
      document.getElementById('status-text').textContent = 'Connected';
    });

    socket.on('disconnect', () => {
      document.getElementById('status-dot').classList.remove('connected');
      document.getElementById('status-text').textContent = 'Disconnected';
    });

    socket.on('components_list', (data) => {
      componentsData = data.components || [];
      if (componentsData.length > 0 && !selectedComponentName) {
        selectedComponentName = componentsData[0].name;
        populateComponentSelector();
        loadInstances();  // Load instances after component is selected
        renderComponentOverview();
      }
    });

    socket.on('instance_created', () => {
      loadInstances();
    });

    socket.on('instance_deallocated', () => {
      loadInstances();
    });

    socket.on('state_change', (data) => {
      console.log('state_change event received:', data);
      // Force refresh instances and re-render
      loadInstances().then(() => {
        // Refresh diagram and transitions if the selected instance changed state
        if (selectedInstanceId && data.instanceId === selectedInstanceId) {
          renderMachineDiagram();
          loadTransitionsForInstance(selectedInstanceId);
          loadInstanceHistory(selectedInstanceId);  // Refresh history
        }
      });
    });

    // Component selector
    function populateComponentSelector() {
      const select = document.getElementById('component-select');
      select.innerHTML = '<option value="">Select a component...</option>' +
        componentsData.map(c =>
          `<option value="${c.name}" ${c.name === selectedComponentName ? 'selected' : ''}>${c.name}</option>`
        ).join('');
    }

    function selectComponent() {
      selectedComponentName = document.getElementById('component-select').value;
      selectedMachineName = null;
      selectedInstanceId = null;
      backToOverview();
      loadInstances();
      renderComponentOverview();
    }

    function getCurrentComponent() {
      if (!selectedComponentName) return null;
      return componentsData.find(c => c.name === selectedComponentName);
    }

    // Set overview display mode
    function setOverviewMode(mode) {
      overviewMode = mode;
      document.getElementById('btn-cards').classList.toggle('active', mode === 'cards');
      document.getElementById('btn-diagrams').classList.toggle('active', mode === 'diagrams');
      renderComponentOverview();
    }

    // Apply current state highlighting and unreachable states graying to Mermaid SVG
    // Also adds timeout countdown badges on states with pending timeouts
    // NEW: Only current state + directly reachable states are colored, everything else is grayed
    function applyStateStyles(card, currentState, reachableStates, pendingTimeouts = [], transitions = []) {
      const svg = card.querySelector('svg');
      if (!svg) return;

      // Compute directly reachable states (1 transition away)
      const directlyReachable = new Set();
      transitions.forEach(t => {
        if (t.from === currentState && t.type !== 'timeout') {
          directlyReachable.add(t.to);
        }
      });

      console.log('Applying styles - currentState:', currentState, 'directlyReachable:', [...directlyReachable]);

      // Mermaid stateDiagram-v2 structure: states are in groups with specific IDs or classes
      // Try finding by state ID pattern first (most reliable)
      const stateGroups = svg.querySelectorAll('[id*="state-"], [id*="statediagram"], g.node, g.state');

      // Collect all state names found
      const foundStates = new Map(); // stateName -> { group, shape, textEls }

      // First pass: find all state groups by looking at group IDs and text content
      svg.querySelectorAll('g').forEach(group => {
        const groupId = group.getAttribute('id') || '';

        // Check if this is a state group by ID
        const idMatch = groupId.match(/state-([^-\s]+)/i);
        if (idMatch) {
          const stateName = idMatch[1];
          const textEls = group.querySelectorAll('text, tspan');
          const shape = group.querySelector('rect, path, polygon, ellipse');
          if (shape) {
            foundStates.set(stateName, { group, shape, textEls: Array.from(textEls) });
          }
          return;
        }

        // Fallback: look for text that could be a state name
        const textEls = Array.from(group.querySelectorAll('text, tspan'));
        for (const textEl of textEls) {
          const text = textEl.textContent?.trim();
          if (text && text.length > 0 && text.length < 50 &&
              !text.includes('-->') && !text.includes(':') &&
              !text.startsWith('[') && text !== '‚óè' && text !== '*') {

            // Include any text that looks like a state name
            const shape = group.querySelector('rect, path, polygon, ellipse');
            if (shape && !foundStates.has(text)) {
              foundStates.set(text, { group, shape, textEls });
            }
          }
        }
      });

      console.log('Found states:', [...foundStates.keys()]);

      // Check if there's no active instance (no current state)
      const hasActiveInstance = currentState && currentState.length > 0;
      const grayOpacity = hasActiveInstance ? '0.5' : '0.4';  // Keep readable even when grayed
      const grayStroke = hasActiveInstance ? '#555' : '#444';
      const grayTextColor = hasActiveInstance ? '#888' : '#777';  // Lighter text for visibility

      // STEP 1: Gray out EVERYTHING first (states, transitions, labels)
      // This ensures all Mermaid native colors are overridden
      svg.querySelectorAll('rect, polygon, ellipse, circle').forEach(shape => {
        shape.style.setProperty('fill', '#1a1a1a', 'important');
        shape.style.setProperty('stroke', grayStroke, 'important');
        shape.style.setProperty('stroke-width', '1px', 'important');
        shape.style.setProperty('opacity', grayOpacity, 'important');
      });
      // Gray out all text elements (including in foreignObject)
      svg.querySelectorAll('text, tspan').forEach(text => {
        text.style.setProperty('fill', grayTextColor, 'important');
        text.style.setProperty('opacity', '1', 'important');  // Keep text fully opaque for readability
      });
      // Gray out foreignObject content (Mermaid uses these for edge labels)
      svg.querySelectorAll('foreignObject span, foreignObject div, .edgeLabel span, .edgeLabel div').forEach(el => {
        el.style.setProperty('color', grayTextColor, 'important');
        el.style.setProperty('opacity', '1', 'important');  // Keep text fully opaque for readability
      });
      // Gray out paths/lines (transitions) - keep them visible but dimmed
      svg.querySelectorAll('path, line').forEach(path => {
        const parent = path.parentElement;
        // Check if this is a transition path (has marker or is in edgePath)
        if (path.hasAttribute('marker-end') ||
            parent?.classList.contains('edgePath') ||
            parent?.classList.contains('transition') ||
            path.getAttribute('class')?.includes('transition') ||
            path.getAttribute('class')?.includes('flowchart')) {
          path.style.setProperty('stroke', grayStroke, 'important');
          path.style.setProperty('opacity', grayOpacity, 'important');
          path.style.setProperty('stroke-width', '1.5px', 'important');
        }
      });
      // Gray out arrow markers
      svg.querySelectorAll('marker path, marker polygon').forEach(marker => {
        marker.style.setProperty('fill', grayStroke, 'important');
        marker.style.setProperty('stroke', grayStroke, 'important');
        marker.style.setProperty('opacity', grayOpacity, 'important');
      });

      // If no active instance, stop here - everything stays grayed
      if (!hasActiveInstance) {
        console.log('No active instance - diagram fully grayed out');
        return;
      }

      // STEP 2: Restore colors for active elements
      foundStates.forEach((data, stateName) => {
        const { group, shape, textEls } = data;

        if (stateName === currentState) {
          // Current state: violet/purple highlighting
          if (shape) {
            shape.style.setProperty('fill', '#4c1d95', 'important');
            shape.style.setProperty('stroke', '#a855f7', 'important');
            shape.style.setProperty('stroke-width', '3px', 'important');
            shape.style.setProperty('opacity', '1', 'important');
            shape.style.setProperty('filter', 'drop-shadow(0 0 12px #a855f7)', 'important');

            // Add timeout countdown badge if there are pending timeouts
            if (pendingTimeouts.length > 0) {
              const timeout = pendingTimeouts[0];
              let bbox = { x: 0, y: 0, width: 100, height: 40 };
              try { if (shape.getBBox) bbox = shape.getBBox(); } catch (e) {}
              if (!bbox || bbox.width < 10) bbox = { x: 0, y: 0, width: 100, height: 40 };

              const countdownGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
              countdownGroup.setAttribute('class', 'timeout-countdown');
              const badgeX = bbox.x + bbox.width - 60;
              const badgeY = bbox.y - 14;

              const badgeBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
              badgeBg.setAttribute('x', String(badgeX));
              badgeBg.setAttribute('y', String(badgeY));
              badgeBg.setAttribute('width', '65');
              badgeBg.setAttribute('height', '22');
              badgeBg.setAttribute('rx', '4');
              badgeBg.style.setProperty('fill', '#ef4444', 'important');
              badgeBg.style.setProperty('opacity', '1', 'important');
              countdownGroup.appendChild(badgeBg);

              const countdownText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              countdownText.setAttribute('x', String(badgeX + 8));
              countdownText.setAttribute('y', String(badgeY + 16));
              countdownText.setAttribute('font-size', '11');
              countdownText.setAttribute('id', `countdown-text-${stateName}`);
              countdownText.style.setProperty('fill', '#ffffff', 'important');
              countdownText.style.setProperty('opacity', '1', 'important');
              countdownText.style.setProperty('font-weight', '600', 'important');
              countdownText.textContent = '‚è± ' + formatTimeRemaining(timeout.remainingMs);
              countdownGroup.appendChild(countdownText);

              group.appendChild(countdownGroup);
              startStateCountdown(stateName, timeout);
            }
          }
          textEls.forEach(t => {
            t.style.setProperty('fill', '#e879f9', 'important');
            t.style.setProperty('opacity', '1', 'important');
            t.style.setProperty('font-weight', '700', 'important');
          });
          console.log('‚úì Highlighted current state:', stateName);

        } else if (directlyReachable.has(stateName)) {
          // Directly reachable state: green highlight
          if (shape) {
            shape.style.setProperty('fill', '#064e3b', 'important');
            shape.style.setProperty('stroke', '#10b981', 'important');
            shape.style.setProperty('stroke-width', '2px', 'important');
            shape.style.setProperty('opacity', '1', 'important');
            shape.style.removeProperty('filter');
          }
          textEls.forEach(t => {
            t.style.setProperty('fill', '#6ee7b7', 'important');
            t.style.setProperty('opacity', '1', 'important');
            t.style.setProperty('font-weight', '600', 'important');
          });
          console.log('‚úì Highlighted reachable state:', stateName);
        }
        // Other states stay grayed (from step 1)
      });

      // STEP 3: Restore transitions from current state
      // Find transition labels and restore their paths
      const activeEvents = new Set();
      transitions.forEach(t => {
        if (t.from === currentState && t.type !== 'timeout') {
          activeEvents.add(t.event);
        }
      });

      console.log('Active events from', currentState, ':', [...activeEvents]);

      // Find ALL text-like elements that could be transition labels
      svg.querySelectorAll('.edgeLabel, .edgeLabels, foreignObject, text, tspan').forEach(container => {
        // Check if this element or its children contain an active event name
        const textContent = container.textContent?.trim();

        if (textContent && activeEvents.has(textContent)) {
          console.log('Found active transition label:', textContent);

          // Restore the label itself
          if (container.tagName === 'text' || container.tagName === 'tspan') {
            container.style.setProperty('fill', '#fbbf24', 'important');
            container.style.setProperty('opacity', '1', 'important');
            container.style.setProperty('font-weight', '600', 'important');
          }

          // Restore any span/div inside foreignObject
          container.querySelectorAll('span, div, p').forEach(el => {
            el.style.setProperty('color', '#fbbf24', 'important');
            el.style.setProperty('opacity', '1', 'important');
            el.style.setProperty('font-weight', '600', 'important');
          });

          // Try to find and restore the associated path
          // Go up to find the edge group, then find its path
          let edgeGroup = container.closest('.edgePath, .edge, g[class*="edge"]');
          if (!edgeGroup) {
            // Try finding sibling edgePath for this label
            const parent = container.parentElement;
            if (parent) {
              edgeGroup = parent.querySelector('.edgePath');
            }
          }

          if (edgeGroup) {
            edgeGroup.querySelectorAll('path, line').forEach(path => {
              path.style.setProperty('stroke', '#fbbf24', 'important');
              path.style.setProperty('opacity', '1', 'important');
              path.style.setProperty('stroke-width', '2px', 'important');
            });
          }
        }
      });

      // If we didn't find states by the above method, try a more aggressive approach
      if (foundStates.size === 0) {
        console.log('No states found by ID/text matching, trying broader search...');
        // Look for any rect/text pair
        svg.querySelectorAll('g').forEach(group => {
          const rect = group.querySelector('rect');
          const text = group.querySelector('text');
          if (rect && text) {
            const stateName = text.textContent?.trim();
            if (stateName === currentState) {
              rect.style.stroke = '#a855f7';
              rect.style.strokeWidth = '4px';
              rect.style.filter = 'drop-shadow(0 0 12px #a855f7)';
              text.style.fill = '#e879f9';
              text.style.fontWeight = '700';
              console.log('‚úì Fallback highlighted:', stateName);
            }
          }
        });
      }
    }

    // Find a state element within a Mermaid SVG by state name
    function findStateElementInSvg(cardElement, stateName) {
      const svg = cardElement.querySelector('svg');
      if (!svg) return null;

      // Try multiple methods to find the state
      // Method 1: Find by ID pattern (Mermaid stateDiagram-v2)
      const byId = svg.querySelector(`[id*="state-${stateName}"]`);
      if (byId) {
        const shape = byId.querySelector('rect, path, polygon, ellipse');
        if (shape) return shape;
      }

      // Method 2: Find by text content in groups
      const allGroups = svg.querySelectorAll('g');
      for (const group of allGroups) {
        const textEls = group.querySelectorAll('text, tspan');
        for (const textEl of textEls) {
          const text = textEl.textContent?.trim();
          if (text === stateName) {
            // Found the text, now find the associated shape
            const shape = group.querySelector('rect, path, polygon, ellipse');
            if (shape) return shape;
            // Try parent group
            const parentShape = group.parentElement?.querySelector('rect, path, polygon, ellipse');
            if (parentShape) return parentShape;
          }
        }
      }

      return null;
    }

    // Get absolute position of an SVG element relative to a container
    function getSvgElementPosition(container, svgElement) {
      if (!svgElement || !container) return null;

      const containerRect = container.getBoundingClientRect();
      const scrollLeft = container.scrollLeft;
      const scrollTop = container.scrollTop;

      // Use getBoundingClientRect for accurate position
      const elemRect = svgElement.getBoundingClientRect();

      return {
        x: elemRect.left - containerRect.left + scrollLeft,
        y: elemRect.top - containerRect.top + scrollTop,
        width: elemRect.width,
        height: elemRect.height,
        centerX: elemRect.left - containerRect.left + scrollLeft + elemRect.width / 2,
        centerY: elemRect.top - containerRect.top + scrollTop + elemRect.height / 2
      };
    }

    // Draw inter-machine arrows from source STATE to target machine's initial STATE
    function drawInterMachineArrows(container, links, machineInitialStates) {
      const svg = container.querySelector('#inter-machine-arrows');
      if (!svg) return;

      // Clear existing arrows
      svg.innerHTML = '';

      // Build arrow definitions - semi-transparent arrowhead
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      defs.innerHTML = `
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto" markerUnits="strokeWidth">
          <polygon points="0 0, 10 3.5, 0 7" fill="#10b981" opacity="0.7" />
        </marker>
      `;
      svg.appendChild(defs);

      // Group arrows by source-target-state to avoid duplicate arrows
      const arrowGroups = {};
      links.forEach(link => {
        const key = `${link.fromMachine}-${link.fromState}-${link.to}`;
        if (!arrowGroups[key]) {
          arrowGroups[key] = {
            fromMachine: link.fromMachine,
            fromState: link.fromState,
            toMachine: link.to,
            events: []
          };
        }
        arrowGroups[key].events.push(link.event);
      });

      // Draw arrows for each unique connection
      Object.values(arrowGroups).forEach((group, groupIndex) => {
        const fromCard = container.querySelector(`.diagram-card[data-machine="${group.fromMachine}"]`);
        const toCard = container.querySelector(`.diagram-card[data-machine="${group.toMachine}"]`);

        if (!fromCard || !toCard) return;

        // Find the source state element within the source machine's diagram
        const sourceStateEl = findStateElementInSvg(fromCard, group.fromState);

        // Find the target machine's initial state
        const targetInitialState = machineInitialStates[group.toMachine];
        const targetStateEl = targetInitialState ? findStateElementInSvg(toCard, targetInitialState) : null;

        // Get positions
        const sourcePos = sourceStateEl ? getSvgElementPosition(container, sourceStateEl) : null;
        const targetPos = targetStateEl ? getSvgElementPosition(container, targetStateEl) : null;

        // Fallback to card positions if states not found
        const containerRect = container.getBoundingClientRect();
        const scrollLeft = container.scrollLeft;
        const scrollTop = container.scrollTop;

        let startX, startY, endX, endY;

        if (sourcePos) {
          // Start from right edge of source state
          startX = sourcePos.x + sourcePos.width;
          startY = sourcePos.centerY;
        } else {
          // Fallback: use card edge
          const fromRect = fromCard.getBoundingClientRect();
          startX = fromRect.right - containerRect.left + scrollLeft;
          startY = fromRect.top - containerRect.top + scrollTop + fromRect.height / 2;
        }

        if (targetPos) {
          // End at left edge of target state
          endX = targetPos.x;
          endY = targetPos.centerY;
        } else {
          // Fallback: use card edge
          const toRect = toCard.getBoundingClientRect();
          endX = toRect.left - containerRect.left + scrollLeft;
          endY = toRect.top - containerRect.top + scrollTop + toRect.height / 2;
        }

        // Determine arrow direction and adjust start/end points
        const dx = endX - startX;
        const dy = endY - startY;
        const isHorizontal = Math.abs(dx) > Math.abs(dy);

        if (sourcePos) {
          if (isHorizontal) {
            if (dx > 0) {
              startX = sourcePos.x + sourcePos.width; // right edge
            } else {
              startX = sourcePos.x; // left edge
            }
            startY = sourcePos.centerY;
          } else {
            if (dy > 0) {
              startY = sourcePos.y + sourcePos.height; // bottom edge
            } else {
              startY = sourcePos.y; // top edge
            }
            startX = sourcePos.centerX;
          }
        }

        if (targetPos) {
          if (isHorizontal) {
            if (dx > 0) {
              endX = targetPos.x; // left edge
            } else {
              endX = targetPos.x + targetPos.width; // right edge
            }
            endY = targetPos.centerY;
          } else {
            if (dy > 0) {
              endY = targetPos.y; // top edge
            } else {
              endY = targetPos.y + targetPos.height; // bottom edge
            }
            endX = targetPos.centerX;
          }
        }

        // Calculate control points for smooth curve
        let cpX1, cpY1, cpX2, cpY2;
        const curvature = Math.min(80, Math.abs(dx) / 3, Math.abs(dy) / 3) + 40;

        if (isHorizontal) {
          cpX1 = startX + (dx > 0 ? curvature : -curvature);
          cpY1 = startY;
          cpX2 = endX + (dx > 0 ? -curvature : curvature);
          cpY2 = endY;
        } else {
          cpX1 = startX;
          cpY1 = startY + (dy > 0 ? curvature : -curvature);
          cpX2 = endX;
          cpY2 = endY + (dy > 0 ? -curvature : curvature);
        }

        // Create the curved path - semi-transparent dashed line
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const d = `M ${startX} ${startY} C ${cpX1} ${cpY1}, ${cpX2} ${cpY2}, ${endX} ${endY}`;
        path.setAttribute('d', d);
        path.setAttribute('stroke', '#10b981');
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-dasharray', '8,4');  // Dashed line for visibility through
        path.setAttribute('fill', 'none');
        path.setAttribute('marker-end', 'url(#arrowhead)');
        path.style.opacity = '0.6';  // More transparent
        svg.appendChild(path);

        // Add label for the event(s) at the middle of the curve
        const labelText = group.events.join(', ');
        // Calculate label position along the curve (at t=0.5)
        const t = 0.5;
        const labelX = Math.pow(1-t, 3) * startX + 3 * Math.pow(1-t, 2) * t * cpX1 + 3 * (1-t) * t * t * cpX2 + Math.pow(t, 3) * endX;
        const labelY = Math.pow(1-t, 3) * startY + 3 * Math.pow(1-t, 2) * t * cpY1 + 3 * (1-t) * t * t * cpY2 + Math.pow(t, 3) * endY - 12;

        // Background for label - semi-transparent
        const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        const textWidth = labelText.length * 7 + 16;
        labelBg.setAttribute('x', labelX - textWidth / 2);
        labelBg.setAttribute('y', labelY - 10);
        labelBg.setAttribute('width', textWidth);
        labelBg.setAttribute('height', 20);
        labelBg.setAttribute('rx', '4');
        labelBg.setAttribute('fill', '#10b981');
        labelBg.setAttribute('opacity', '0.75');  // More transparent label bg
        svg.appendChild(labelBg);

        // Label text
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', labelX);
        text.setAttribute('y', labelY + 4);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '10');  // Slightly smaller
        text.setAttribute('font-weight', '600');
        text.setAttribute('fill', '#ffffff');
        text.textContent = labelText;
        svg.appendChild(text);
      });

      // Update SVG dimensions to cover all content
      const gridContainer = container.querySelector('#diagram-grid-container');
      if (gridContainer) {
        const gridRect = gridContainer.getBoundingClientRect();
        svg.style.width = Math.max(gridRect.width, container.scrollWidth) + 'px';
        svg.style.height = Math.max(gridRect.height + 200, container.scrollHeight) + 'px';
      }
    }

    // Track active state countdown intervals
    const stateCountdownIntervals = new Map();

    // Start a live countdown update for a state in the diagram
    function startStateCountdown(stateName, timeout) {
      // Clear existing interval for this state
      if (stateCountdownIntervals.has(stateName)) {
        clearInterval(stateCountdownIntervals.get(stateName));
      }

      const startTime = Date.now();
      const initialRemaining = timeout.remainingMs;

      const intervalId = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const newRemaining = Math.max(0, initialRemaining - elapsed);

        const textEl = document.getElementById(`countdown-text-${stateName}`);
        if (textEl) {
          textEl.textContent = formatTimeRemaining(newRemaining);

          // Add pulsing effect when under 1 minute
          if (newRemaining < 60000 && newRemaining > 0) {
            const parentGroup = textEl.closest('.timeout-countdown');
            if (parentGroup) {
              parentGroup.style.animation = 'pulse 1s ease-in-out infinite';
            }
          }
        }

        // Stop and refresh when timeout expires
        if (newRemaining <= 0) {
          clearInterval(intervalId);
          stateCountdownIntervals.delete(stateName);
          setTimeout(() => loadInstances(), 500);
        }
      }, 1000);

      stateCountdownIntervals.set(stateName, intervalId);
    }

    // Clear all state countdown intervals
    function clearStateCountdowns() {
      stateCountdownIntervals.forEach((intervalId) => clearInterval(intervalId));
      stateCountdownIntervals.clear();
    }

    // Compute reachable states from current state (BFS)
    function computeReachableStatesJS(transitions, currentState) {
      const reachable = new Set([currentState]);
      const queue = [currentState];

      while (queue.length > 0) {
        const state = queue.shift();
        transitions.forEach(t => {
          if (t.from === state && !reachable.has(t.to)) {
            reachable.add(t.to);
            queue.push(t.to);
          }
        });
      }

      return reachable;
    }

    // Component Overview - Show all machines with inter-machine connections
    async function renderComponentOverview() {
      const component = getCurrentComponent();
      if (!component) {
        document.getElementById('component-graph').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üé®</div>
            <div>No component loaded</div>
          </div>`;
        return;
      }

      document.getElementById('overview-title').textContent = `${component.name} - Component Overview`;

      const machines = component.stateMachines || [];
      const container = document.getElementById('component-graph');

      if (overviewMode === 'diagrams') {
        // Diagram mode: Show full Mermaid diagrams with current state

        // Collect inter-machine transitions for overview flowchart
        const interMachineLinks = [];
        const machineInitialStates = {};
        machines.forEach(machine => {
          machineInitialStates[machine.name] = machine.initialState;
          (machine.transitions || []).forEach(transition => {
            if (transition.type === 'inter_machine' && transition.targetMachine) {
              interMachineLinks.push({
                fromMachine: machine.name,
                fromState: transition.from,
                to: transition.targetMachine,
                event: transition.event
              });
            }
          });
        });

        // Build inter-machine flowchart if there are connections
        let interMachineFlowchartHtml = '';
        if (interMachineLinks.length > 0) {
          let flowchartDef = 'flowchart LR\n';

          // Add nodes
          machines.forEach(machine => {
            const isEntry = component.entryMachine === machine.name;
            const icon = isEntry ? '‚≠ê' : 'üì¶';
            flowchartDef += `  ${machine.name}["${icon} ${machine.name}"]\n`;
          });

          // Add inter-machine connections
          interMachineLinks.forEach(link => {
            flowchartDef += `  ${link.fromMachine} -->|"üîó ${link.event}"| ${link.to}\n`;
          });

          // Style nodes
          flowchartDef += '  classDef entryNode fill:#fbbf24,stroke:#f59e0b,color:#000,stroke-width:2px\n';
          flowchartDef += '  classDef normalNode fill:#1f2937,stroke:#4b5563,color:#f0f0f0,stroke-width:1px\n';
          machines.forEach(machine => {
            const isEntry = component.entryMachine === machine.name;
            flowchartDef += `  class ${machine.name} ${isEntry ? 'entryNode' : 'normalNode'}\n`;
          });
          flowchartDef += '  linkStyle default stroke:#10b981,stroke-width:3px\n';

          interMachineFlowchartHtml = `
            <div style="margin-bottom: 20px; padding: 16px; background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 12px;">
              <div style="font-size: 12px; color: #10b981; font-weight: 600; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                <span>üîó</span> Inter-Machine Connections
              </div>
              <div class="mermaid" id="inter-machine-flowchart">${flowchartDef}</div>
            </div>`;
        }

        let diagramsHtml = interMachineFlowchartHtml + '<div class="diagram-grid" id="diagram-grid-container">';

        // Store machine state info for post-render styling
        const machineStateInfo = [];

        for (const machine of machines) {
          const isEntry = component.entryMachine === machine.name;
          const machineInstances = allInstances.filter(i => i.machineName === machine.name);

          try {
            // Get first instance of this machine to show its current state
            // Use cache-busting timestamp
            let url = `/api/machines/${machine.name}/diagram?t=${Date.now()}`;
            let currentStateText = '';
            let quickActionsHtml = '';
            let currentState = null;

            if (machineInstances.length > 0) {
              const firstInstance = machineInstances[0];
              currentState = firstInstance.currentState;
              url += `&instanceId=${firstInstance.id}`;

              // Store info for post-render styling (including pending timeouts)
              machineStateInfo.push({
                machineName: machine.name,
                currentState: currentState,
                transitions: machine.transitions || [],
                pendingTimeouts: firstInstance.pendingTimeouts || []
              });

              currentStateText = `<div style="margin-top: 8px; padding: 8px 12px; background: linear-gradient(135deg, #a855f7, #7c3aed); border-radius: 8px; color: #fff; font-size: 13px; font-weight: 700; text-align: center; box-shadow: 0 2px 8px rgba(168, 85, 247, 0.4);">
                üéØ Current: ${currentState}
              </div>`;

              // Get available transitions from current state (deduplicated by event name, excluding timeouts)
              const allTransitions = (machine.transitions || []).filter(t =>
                t.from === currentState && t.type !== 'timeout'  // Timeout transitions are automatic, not manual
              );
              // Deduplicate by event name - keep first occurrence (guards/matching rules handle routing)
              const seenEvents = new Set();
              const availableTransitions = allTransitions.filter(t => {
                if (seenEvents.has(t.event)) return false;
                seenEvents.add(t.event);
                return true;
              });
              if (availableTransitions.length > 0) {
                // Get schema for transition - either target machine's schema (inter_machine)
                // or current machine's schema (for regular transitions that need input)
                const getTransitionSchema = (t) => {
                  if (t.type === 'inter_machine' && t.targetMachine) {
                    const targetMachine = component.stateMachines.find(m => m.name === t.targetMachine);
                    return targetMachine?.contextSchema || null;
                  }
                  // For regular transitions from initial state, only show contextSchema if this is the entry machine
                  // Non-entry machines get their context from the inter_machine transition that creates them
                  const isEntryMachine = component.entryMachine === machine.name;
                  if (isEntryMachine && machine.contextSchema && currentState === machine.initialState) {
                    return machine.contextSchema;
                  }
                  return null;
                };

                // Build Quick Actions with inline parameter forms
                const transitionsHtml = availableTransitions.map(t => {
                  const isInterMachine = t.type === 'inter_machine';
                  const btnColor = isInterMachine ? '#10b981' : '#3b82f6';
                  const icon = isInterMachine ? 'üîó' : '‚Üí';
                  const schema = getTransitionSchema(t);
                  const hasParams = schema && Object.keys(schema).length > 0;
                  const formId = `overview-form-${machine.name}-${t.event}`.replace(/[^a-zA-Z0-9-]/g, '-');

                  // Build inline parameter inputs if schema exists
                  let paramsHtml = '';
                  const requiredKeys = [];
                  if (hasParams) {
                    paramsHtml = `<div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;">
                      ${Object.entries(schema).map(([key, field]) => {
                        const inputId = `${formId}-${key}`;
                        const inputType = field.type === 'number' ? 'number' : 'text';
                        if (field.required) requiredKeys.push(key);
                        return `<input type="${inputType}" id="${inputId}" placeholder="${field.label || key}${field.required ? '*' : ''}"
                          style="flex: 1; min-width: 80px; padding: 6px 8px; background: var(--bg-tertiary); border: 1px solid var(--glass-border); border-radius: 4px; color: var(--text-primary); font-size: 11px;"
                          onclick="event.stopPropagation()" onfocus="this.style.borderColor='var(--glass-border)'; this.style.boxShadow='none'">`;
                      }).join('')}
                    </div>`;
                  }

                  // Escape JSON for HTML attribute context
                  const paramKeysJson = hasParams ? JSON.stringify(Object.keys(schema)).replace(/"/g, '&quot;') : '[]';
                  const requiredKeysJson = requiredKeys.length > 0 ? JSON.stringify(requiredKeys).replace(/"/g, '&quot;') : '[]';

                  return `<div style="margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.15); border-radius: 6px; border-left: 3px solid ${btnColor};">
                    ${paramsHtml}
                    <button onclick="event.stopPropagation(); sendQuickEventWithParams('${firstInstance.id}', '${t.event}', '${formId}', ${paramKeysJson}, ${requiredKeysJson})"
                      style="width: 100%; padding: 8px 12px; background: ${btnColor}; border: none; border-radius: 6px; color: white; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.15s;"
                      onmouseover="this.style.opacity='0.85'"
                      onmouseout="this.style.opacity='1'"
                      title="${t.from} ‚Üí ${t.to}${isInterMachine ? ' (creates ' + t.targetMachine + ')' : ''}">
                      ${icon} ${t.event}${isInterMachine ? ' ‚Üí ' + t.targetMachine : ''}
                    </button>
                  </div>`;
                }).join('');

                quickActionsHtml = `<div class="quick-actions" style="margin-top: 12px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);" onclick="event.stopPropagation()">
                  <div style="font-size: 11px; color: #888; margin-bottom: 8px; font-weight: 600;">‚ö° Quick Actions</div>
                  ${transitionsHtml}
                </div>`;
              }
            }

            const res = await fetch(url);
            const data = await res.json();

            diagramsHtml += `
              <div class="diagram-card ${isEntry ? 'entry-machine' : ''}" data-machine="${machine.name}" onclick="selectMachine('${machine.name}')">
                <div class="diagram-card-header">
                  <div class="diagram-card-title">
                    ${machine.name}
                    ${isEntry ? '<span class="entry-star">‚≠ê</span>' : ''}
                  </div>
                  <span class="instance-badge">${machineInstances.length} instances</span>
                </div>
                <div class="diagram-card-content">
                  <div class="mermaid">${data.diagram}</div>
                  ${currentStateText}
                  ${quickActionsHtml}
                </div>
              </div>`;
          } catch (error) {
            console.error(`Error loading diagram for ${machine.name}:`, error);
          }
        }

        diagramsHtml += '</div>';
        // Add SVG overlay for inter-machine arrows
        diagramsHtml += '<svg id="inter-machine-arrows" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></svg>';
        container.innerHTML = diagramsHtml;
        container.style.position = 'relative';
        container.style.height = 'auto';

        // Render inter-machine flowchart first (if exists)
        if (interMachineLinks.length > 0) {
          await mermaid.run({ querySelector: '#inter-machine-flowchart' });
        }

        // Render all state machine diagrams
        await mermaid.run({ querySelector: '.diagram-card-content .mermaid' });

        // Apply current state highlighting and gray out unreachable states after Mermaid renders
        setTimeout(() => {
          // Clear any existing state countdowns before re-applying
          clearStateCountdowns();

          console.log('Applying state styles, machineStateInfo:', machineStateInfo);

          machineStateInfo.forEach(info => {
            const card = container.querySelector(`.diagram-card[data-machine="${info.machineName}"]`);
            if (card) {
              // Always apply styles - will gray out completely if no currentState (no instance)
              console.log(`Applying styles for ${info.machineName}: state=${info.currentState || 'NONE'}, timeouts=`, info.pendingTimeouts);
              const reachableStates = info.currentState ? computeReachableStatesJS(info.transitions, info.currentState) : new Set();
              applyStateStyles(card, info.currentState || null, reachableStates, info.pendingTimeouts || [], info.transitions || []);
            }
          });

          // Draw inter-machine arrows from source state to target initial state
          if (interMachineLinks.length > 0) {
            drawInterMachineArrows(container, interMachineLinks, machineInitialStates);
          }
        }, 300);

      } else {
        // Cards mode: Use Mermaid flowchart to show inter-machine connections
        // Build flowchart diagram
        let flowchartDef = 'flowchart LR\n';

        // Define machine nodes with instance counts
        machines.forEach(machine => {
          const isEntry = component.entryMachine === machine.name;
          const machineInstances = allInstances.filter(i => i.machineName === machine.name);
          const icon = isEntry ? '‚≠ê ' : '';
          const label = `${icon}${machine.name}<br/>${machine.states.length} states | ${machineInstances.length} inst`;
          flowchartDef += `  ${machine.name}["${label}"]\n`;
        });

        // Add inter-machine connections with green styling
        machines.forEach(machine => {
          (machine.transitions || []).forEach(transition => {
            if (transition.type === 'inter_machine' && transition.targetMachine) {
              flowchartDef += `  ${machine.name} -->|"üîó ${transition.event}"| ${transition.targetMachine}\n`;
            }
          });
        });

        // Add styling
        flowchartDef += `  classDef entryNode fill:#fbbf24,stroke:#f59e0b,color:#000,stroke-width:2px\n`;
        flowchartDef += `  classDef normalNode fill:#1f2937,stroke:#4b5563,color:#f0f0f0,stroke-width:1px\n`;

        // Apply styles
        machines.forEach(machine => {
          const isEntry = component.entryMachine === machine.name;
          flowchartDef += `  class ${machine.name} ${isEntry ? 'entryNode' : 'normalNode'}\n`;
        });

        // Add link styling for green inter-machine arrows
        flowchartDef += `  linkStyle default stroke:#10b981,stroke-width:3px\n`;

        container.innerHTML = `
          <div style="padding: 40px; display: flex; flex-direction: column; align-items: center;">
            <div class="mermaid" id="component-flowchart">${flowchartDef}</div>
            <div style="margin-top: 24px; display: flex; gap: 16px; flex-wrap: wrap; justify-content: center;">
              ${machines.map(machine => {
                const isEntry = component.entryMachine === machine.name;
                return `<button onclick="selectMachine('${machine.name}')"
                  style="padding: 12px 20px; background: ${isEntry ? 'linear-gradient(135deg, #fbbf24, #f59e0b)' : 'var(--bg-tertiary)'};
                         border: 1px solid ${isEntry ? '#f59e0b' : 'var(--glass-border)'}; border-radius: 8px;
                         color: ${isEntry ? '#000' : 'var(--text-primary)'}; font-size: 13px; font-weight: 600; cursor: pointer;">
                  ${isEntry ? '‚≠ê ' : ''}${machine.name}
                </button>`;
              }).join('')}
            </div>
          </div>`;
        container.style.position = 'relative';
        container.style.height = 'auto';

        // Render the flowchart
        await mermaid.run({ querySelector: '#component-flowchart' });
      }
    }

    // Select machine to view detail
    function selectMachine(machineName) {
      selectedMachineName = machineName;
      document.getElementById('component-overview').classList.add('hidden');
      document.getElementById('machine-detail').classList.add('active');
      document.getElementById('detail-title').textContent = machineName;
      renderInstanceList();  // Refresh to show only this machine's instances
      renderMachineDiagram();
    }

    // Back to overview
    function backToOverview() {
      selectedMachineName = null;
      selectedInstanceId = null;
      document.getElementById('component-overview').classList.remove('hidden');
      document.getElementById('machine-detail').classList.remove('active');
      clearTransitions();
      renderInstanceContext(null);
      loadInstanceHistory(null);
      renderInstanceList();  // Refresh to show all instances
    }

    // Render machine diagram
    async function renderMachineDiagram() {
      const component = getCurrentComponent();
      if (!component || !selectedMachineName) return;

      const machine = component.stateMachines.find(m => m.name === selectedMachineName);
      if (!machine) return;

      // Store transitions for later use
      currentTransitions = machine.transitions.map(t => ({
        from: t.from,
        to: t.to,
        event: t.event,
        type: t.type || 'regular',
        targetMachine: t.targetMachine
      }));

      // Find the instance to display - use selected or auto-select first instance of this machine
      let instanceToDisplay = null;
      if (selectedInstanceId) {
        instanceToDisplay = allInstances.find(i => i.id === selectedInstanceId);
      }
      if (!instanceToDisplay) {
        // Auto-select first instance of this machine
        instanceToDisplay = allInstances.find(i => i.machineName === selectedMachineName);
      }

      try {
        // Add currentState to URL if we have an instance
        let url = `/api/machines/${selectedMachineName}/diagram`;
        if (instanceToDisplay) {
          url += `?currentState=${encodeURIComponent(instanceToDisplay.currentState)}`;
        }

        const res = await fetch(url);
        const data = await res.json();

        const container = document.getElementById('diagram-container');
        const currentState = instanceToDisplay ? instanceToDisplay.currentState : null;

        // Build diagram HTML with current state badge if available
        let diagramHtml = '<div class="mermaid">' + data.diagram + '</div>';

        if (currentState) {
          diagramHtml += `<div style="margin-top: 12px; padding: 8px 16px; background: linear-gradient(135deg, #a855f7, #7c3aed); border-radius: 8px; color: #fff; font-size: 14px; font-weight: 700; text-align: center; box-shadow: 0 2px 8px rgba(168, 85, 247, 0.4);">
            üéØ Current: ${currentState}
          </div>`;
        }

        container.innerHTML = diagramHtml;
        await mermaid.run({ querySelector: '#diagram-container .mermaid' });

        // Apply state highlighting and timeout countdown if we have an instance
        if (currentState && instanceToDisplay) {
          // Clear previous countdowns
          clearStateCountdowns();

          // Compute reachable states and apply styles
          const reachableStates = computeReachableStatesJS(machine.transitions, currentState);
          const pendingTimeouts = instanceToDisplay.pendingTimeouts || [];

          // Apply styles to the diagram container (acts like a card)
          setTimeout(() => {
            applyStateStyles(container, currentState, reachableStates, pendingTimeouts, machine.transitions);
          }, 100);
        }
      } catch (error) {
        console.error('Error rendering diagram:', error);
        document.getElementById('diagram-container').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">‚ö†Ô∏è</div>
            <div>Error rendering diagram</div>
          </div>`;
      }
    }

    // Instance Management
    async function loadInstances() {
      // Add cache-busting timestamp
      const res = await fetch(`/api/instances?t=${Date.now()}`);
      const data = await res.json();
      allInstances = data.instances || [];
      console.log('loadInstances: loaded', allInstances.length, 'instances');

      // Debug: log instances with their transition info
      allInstances.forEach(inst => {
        console.log(`Instance ${inst.id} (${inst.machineName}/${inst.currentState}):`, {
          pendingTimeouts: inst.pendingTimeouts,
          _debug: inst._debug
        });
      });

      renderInstanceList();
      updateStats();

      // Update component overview if visible
      const overviewHidden = document.getElementById('component-overview').classList.contains('hidden');
      console.log('loadInstances: overview hidden?', overviewHidden);
      if (!overviewHidden) {
        console.log('loadInstances: calling renderComponentOverview');
        await renderComponentOverview();
      }
    }

    function renderInstanceList() {
      const container = document.getElementById('instance-list');
      const countEl = document.getElementById('instance-count');
      const filterInput = document.getElementById('instance-filter');
      const filterText = (filterInput?.value || '').toLowerCase().trim();
      const component = getCurrentComponent();

      if (!component) {
        container.innerHTML = `
          <div class="empty-state" style="padding: 40px 20px;">
            <div class="empty-state-icon">üì¶</div>
            <div style="font-size: 12px;">No component selected</div>
          </div>`;
        if (countEl) countEl.textContent = '';
        return;
      }

      // Filter instances: by selected machine (when in detail view) and by search text
      let filteredInstances = allInstances;

      // If in detail view (machine selected), only show instances of that machine
      if (selectedMachineName && document.getElementById('machine-detail').classList.contains('active')) {
        filteredInstances = filteredInstances.filter(i => i.machineName === selectedMachineName);
      }

      // Apply text filter
      if (filterText) {
        filteredInstances = filteredInstances.filter(instance => {
          const contextData = instance.publicMember || instance.context || {};
          const searchableText = [
            instance.id,
            instance.machineName,
            instance.currentState,
            ...Object.values(contextData).map(v => String(v))
          ].join(' ').toLowerCase();
          return searchableText.includes(filterText);
        });
      }

      // Update count display
      if (countEl) {
        const machineFilter = selectedMachineName && document.getElementById('machine-detail').classList.contains('active')
          ? ` (${selectedMachineName})`
          : '';
        countEl.textContent = `(${filteredInstances.length}${machineFilter})`;
      }

      if (filteredInstances.length === 0) {
        container.innerHTML = `
          <div class="empty-state" style="padding: 40px 20px;">
            <div class="empty-state-icon">üì¶</div>
            <div style="font-size: 12px;">${filterText ? 'No matching instances' : 'No instances'}</div>
          </div>`;
        return;
      }

      // Group filtered instances by machine
      const instancesByMachine = {};
      filteredInstances.forEach(instance => {
        if (!instancesByMachine[instance.machineName]) {
          instancesByMachine[instance.machineName] = [];
        }
        instancesByMachine[instance.machineName].push(instance);
      });

      let html = '';
      component.stateMachines.forEach(machine => {
        const instances = instancesByMachine[machine.name] || [];
        instances.forEach(instance => {
          const isEntry = component.entryMachine === machine.name;
          const isSelected = instance.id === selectedInstanceId;

          // Format context/publicMember preview (first 2 fields)
          const contextData = instance.publicMember || instance.context || {};
          const contextEntries = Object.entries(contextData).slice(0, 2);
          const contextPreview = contextEntries.length > 0
            ? contextEntries.map(([k, v]) => `<span style="color: #888;">${k}:</span> <span style="color: #aaa;">${String(v).substring(0, 15)}${String(v).length > 15 ? '...' : ''}</span>`).join(', ')
            : '';
          const hasMoreContext = Object.keys(contextData).length > 2;

          html += `
            <div class="instance-item ${isSelected ? 'selected' : ''}" onclick="selectInstance('${instance.id}')">
              <div class="instance-header">
                <span class="instance-machine">${machine.name}</span>
                ${isEntry ? '<span class="entry-badge">‚≠ê Entry</span>' : ''}
              </div>
              <div class="instance-id">${instance.id.substring(0, 8)}</div>
              <div class="instance-state">State: ${instance.currentState}</div>
              ${contextPreview ? `<div style="font-size: 10px; margin-top: 4px; color: #666;">${contextPreview}${hasMoreContext ? ' ...' : ''}</div>` : ''}
            </div>`;
        });
      });

      container.innerHTML = html;
    }

    function selectInstance(instanceId) {
      selectedInstanceId = instanceId;
      const instance = allInstances.find(i => i.id === instanceId);

      if (instance && instance.machineName !== selectedMachineName) {
        // Switch to the machine view if not already there
        selectMachine(instance.machineName);
      } else {
        // Refresh diagram to highlight current state
        renderMachineDiagram();
      }

      renderInstanceList();
      loadTransitionsForInstance(instanceId);
      renderInstanceContext(instance);
      loadInstanceHistory(instanceId);
    }

    // Timer interval for countdown updates (for Instance Data panel)
    let countdownInterval = null;

    // Render instance context/publicMember with timeout countdown
    function renderInstanceContext(instance) {
      const container = document.getElementById('instance-context');
      if (!container) return;

      // Clear previous countdown interval
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }

      if (!instance) {
        container.innerHTML = '<div style="font-size: 12px; color: #666;">Select an instance to see its data</div>';
        return;
      }

      const contextData = instance.publicMember || instance.context || {};
      const entries = Object.entries(contextData);
      const pendingTimeouts = instance.pendingTimeouts || [];

      // Build timeout countdown HTML
      let timeoutHtml = '';
      if (pendingTimeouts.length > 0) {
        timeoutHtml = `
          <div style="margin-bottom: 12px; padding: 10px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px;">
            <div style="font-size: 10px; color: #ef4444; font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
              <span>‚è±Ô∏è</span> Pending Timeouts
            </div>
            ${pendingTimeouts.map((timeout, idx) => {
              const percentage = Math.max(0, Math.min(100, ((timeout.totalMs - timeout.remainingMs) / timeout.totalMs) * 100));
              return `
                <div style="margin-bottom: 8px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="font-size: 11px; color: #fbbf24;">${timeout.event}</span>
                    <span id="timeout-countdown-${idx}" style="font-size: 11px; color: #f87171; font-weight: 600;">${formatTimeRemaining(timeout.remainingMs)}</span>
                  </div>
                  <div style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                    <div id="timeout-bar-${idx}" style="height: 100%; width: ${percentage}%; background: linear-gradient(90deg, #ef4444, #f59e0b); border-radius: 3px; transition: width 1s linear;"></div>
                  </div>
                  <div style="font-size: 9px; color: #666; margin-top: 2px;">‚Üí ${timeout.targetState}</div>
                </div>`;
            }).join('')}
          </div>`;

        // Start countdown interval
        const startTime = Date.now();
        const initialTimeouts = pendingTimeouts.map(t => ({ ...t }));

        countdownInterval = setInterval(() => {
          const elapsed = Date.now() - startTime;
          let anyActive = false;

          initialTimeouts.forEach((timeout, idx) => {
            const newRemaining = Math.max(0, timeout.remainingMs - elapsed);
            const percentage = Math.max(0, Math.min(100, ((timeout.totalMs - newRemaining) / timeout.totalMs) * 100));

            const countdownEl = document.getElementById(`timeout-countdown-${idx}`);
            const barEl = document.getElementById(`timeout-bar-${idx}`);

            if (countdownEl) {
              countdownEl.textContent = formatTimeRemaining(newRemaining);
              if (newRemaining <= 0) {
                countdownEl.style.color = '#ef4444';
                countdownEl.style.animation = 'none';
              } else if (newRemaining < 60000) {
                countdownEl.style.animation = 'pulse 1s ease-in-out infinite';
              }
            }
            if (barEl) {
              barEl.style.width = `${percentage}%`;
            }

            if (newRemaining > 0) anyActive = true;
          });

          // Stop interval if all timeouts expired
          if (!anyActive) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            // Refresh instances to get updated state
            setTimeout(() => loadInstances(), 500);
          }
        }, 1000);
      }

      // Build context data HTML
      let contextHtml = '';
      if (entries.length > 0) {
        contextHtml = `
          <div style="display: flex; flex-direction: column; gap: 6px;">
            ${entries.map(([key, value]) => {
              const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
              return `
                <div style="display: flex; justify-content: space-between; padding: 6px 8px; background: rgba(255,255,255,0.03); border-radius: 4px; border-left: 2px solid #3b82f6;">
                  <span style="color: #888; font-size: 11px;">${key}</span>
                  <span style="color: #f0f0f0; font-size: 11px; font-weight: 500; max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${displayValue}">${displayValue}</span>
                </div>`;
            }).join('')}
          </div>`;
      }

      // Build parent info HTML if this instance was created by another
      let parentHtml = '';
      if (instance.parentInstanceId) {
        const parentInstance = allInstances.find(i => i.id === instance.parentInstanceId);
        const parentState = parentInstance ? parentInstance.currentState : '?';
        parentHtml = `
          <div style="margin-bottom: 10px; padding: 8px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 6px;">
            <div style="font-size: 10px; color: #3b82f6; font-weight: 600; margin-bottom: 4px;">üîó Created by</div>
            <div style="font-size: 11px; color: #888;">
              <span style="color: #f0f0f0;">${instance.parentMachineName || 'Unknown'}</span>
              <span style="color: #666; margin: 0 4px;">‚Üí</span>
              <span style="color: #a855f7; cursor: pointer; text-decoration: underline;" onclick="selectInstance('${instance.parentInstanceId}')">${instance.parentInstanceId.substring(0, 8)}...</span>
              <span style="color: #666; margin-left: 4px;">(${parentState})</span>
            </div>
          </div>`;
      }

      container.innerHTML = `
        <div style="font-size: 10px; color: #888; margin-bottom: 8px;">ID: ${instance.id.substring(0, 8)}... | State: <span style="color: #a855f7; font-weight: 600;">${instance.currentState}</span></div>
        ${parentHtml}
        ${timeoutHtml}
        ${contextHtml || '<div style="font-size: 11px; color: #666;">No context data</div>'}
      `;
    }

    // Instance History/Traceability
    async function loadInstanceHistory(instanceId) {
      const container = document.getElementById('instance-history');
      if (!container) return;

      if (!instanceId) {
        container.innerHTML = '<div style="font-size: 12px; color: #666;">Select an instance to see its history</div>';
        return;
      }

      container.innerHTML = '<div style="font-size: 12px; color: #888;">Loading history...</div>';

      try {
        const res = await fetch(`/api/instances/${instanceId}/history`);
        const data = await res.json();
        const history = data.history || [];

        if (history.length === 0) {
          container.innerHTML = '<div style="font-size: 12px; color: #666;">No history available</div>';
          return;
        }

        // Sort by timestamp (most recent first)
        history.sort((a, b) => b.persistedAt - a.persistedAt);

        const historyHtml = history.map((event, idx) => {
          const time = new Date(event.persistedAt).toLocaleTimeString();
          const date = new Date(event.persistedAt).toLocaleDateString();
          const eventType = event.event?.type || 'Unknown';
          const payload = event.event?.payload || {};
          const payloadEntries = Object.entries(payload);

          // Format state transition
          const stateTransition = event.stateBefore !== event.stateAfter
            ? `<span style="color: #888;">${event.stateBefore}</span> <span style="color: #22c55e;">‚Üí</span> <span style="color: #a855f7; font-weight: 600;">${event.stateAfter}</span>`
            : `<span style="color: #888;">stayed in</span> <span style="color: #a855f7;">${event.stateAfter}</span>`;

          // Build payload display
          let payloadHtml = '';
          if (payloadEntries.length > 0) {
            payloadHtml = `
              <div style="margin-top: 6px; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 10px;">
                ${payloadEntries.map(([key, value]) => {
                  const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
                  return `<div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                    <span style="color: #666;">${key}:</span>
                    <span style="color: #f0f0f0; max-width: 120px; overflow: hidden; text-overflow: ellipsis;" title="${displayValue}">${displayValue}</span>
                  </div>`;
                }).join('')}
              </div>`;
          }

          // Build publicMember snapshot display
          let publicMemberHtml = '';
          const publicMember = event.publicMemberSnapshot;
          if (publicMember && Object.keys(publicMember).length > 0) {
            const memberEntries = Object.entries(publicMember);
            publicMemberHtml = `
              <div style="margin-top: 6px; padding: 6px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2); border-radius: 4px; font-size: 10px;">
                <div style="color: #3b82f6; font-weight: 600; margin-bottom: 4px;">üì¶ Data snapshot:</div>
                ${memberEntries.map(([key, value]) => {
                  const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
                  return `<div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                    <span style="color: #666;">${key}:</span>
                    <span style="color: #f0f0f0; max-width: 120px; overflow: hidden; text-overflow: ellipsis;" title="${displayValue}">${displayValue}</span>
                  </div>`;
                }).join('')}
              </div>`;
          }

          // Determine event icon and color based on type
          let eventIcon = '‚ö°';
          let eventColor = '#3b82f6';
          if (eventType === 'INSTANCE_CREATED') { eventIcon = 'üÜï'; eventColor = '#10b981'; }
          else if (eventType.includes('APPROVE')) { eventIcon = '‚úÖ'; eventColor = '#22c55e'; }
          else if (eventType.includes('REJECT')) { eventIcon = '‚ùå'; eventColor = '#ef4444'; }
          else if (eventType.includes('SUBMIT')) { eventIcon = 'üì§'; eventColor = '#f59e0b'; }
          else if (eventType.includes('CANCEL')) { eventIcon = 'üö´'; eventColor = '#6b7280'; }
          else if (eventType.includes('TIMEOUT')) { eventIcon = '‚è∞'; eventColor = '#f97316'; }
          else if (eventType.includes('REVISE') || eventType.includes('CHANGE')) { eventIcon = '‚úèÔ∏è'; eventColor = '#8b5cf6'; }

          // Special formatting for INSTANCE_CREATED event
          let creationInfoHtml = '';
          if (eventType === 'INSTANCE_CREATED' && payload.parentInstanceId) {
            creationInfoHtml = `
              <div style="margin-top: 6px; padding: 6px; background: rgba(16, 185, 129, 0.1); border-radius: 4px; font-size: 10px;">
                <div style="color: #10b981; font-weight: 600; margin-bottom: 4px;">üîó Triggered by:</div>
                <div style="color: #888;">
                  Machine: <span style="color: #f0f0f0;">${payload.parentMachineName || 'Unknown'}</span>
                </div>
                <div style="color: #888;">
                  Instance: <span style="color: #a855f7; cursor: pointer; text-decoration: underline;" onclick="selectInstance('${payload.parentInstanceId}')">${payload.parentInstanceId.substring(0, 8)}...</span>
                </div>
              </div>`;
          }

          return `
            <div style="padding: 10px; background: rgba(255,255,255,0.03); border-radius: 6px; margin-bottom: 8px; border-left: 3px solid ${eventColor};">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                <span style="font-size: 12px; font-weight: 600; color: ${eventColor};">${eventIcon} ${eventType}</span>
                <span style="font-size: 9px; color: #666;">${time}</span>
              </div>
              <div style="font-size: 11px; margin-bottom: 4px;">${stateTransition}</div>
              ${creationInfoHtml || payloadHtml}
              ${publicMemberHtml}
              <div style="font-size: 9px; color: #555; margin-top: 4px;">${date}</div>
            </div>`;
        }).join('');

        container.innerHTML = historyHtml;
      } catch (error) {
        console.error('Error loading instance history:', error);
        container.innerHTML = '<div style="font-size: 12px; color: #ef4444;">Error loading history</div>';
      }
    }

    // Transitions Panel
    function loadTransitionsForInstance(instanceId) {
      const instance = allInstances.find(i => i.id === instanceId);
      if (!instance) {
        clearTransitions();
        renderInstanceContext(null);
        loadInstanceHistory(null);
        return;
      }

      // Filter transitions that start from current state (deduplicated by event name, excluding timeouts)
      const allTransitions = currentTransitions.filter(t =>
        t.from === instance.currentState && t.type !== 'timeout'  // Timeout transitions are automatic, not manual
      );
      // Deduplicate by event name - keep first occurrence (guards/matching rules handle routing)
      const seenEvents = new Set();
      const availableTransitions = allTransitions.filter(t => {
        if (seenEvents.has(t.event)) return false;
        seenEvents.add(t.event);
        return true;
      });
      renderTransitions(availableTransitions, instance);
    }

    // Get contextSchema for a transition - either target machine (inter_machine) or entry machine
    function getTransitionSchema(transition, instance) {
      const component = getCurrentComponent();
      if (!component) return null;

      if (transition.type === 'inter_machine' && transition.targetMachine) {
        const targetMachine = component.stateMachines.find(m => m.name === transition.targetMachine);
        return targetMachine?.contextSchema || null;
      }

      // For regular transitions from initial state, only show contextSchema if this is the entry machine
      // Non-entry machines get their context from the inter_machine transition that creates them
      if (instance) {
        const currentMachine = component.stateMachines.find(m => m.name === instance.machineName);
        const isEntryMachine = component.entryMachine === instance.machineName;
        if (isEntryMachine && currentMachine?.contextSchema && instance.currentState === currentMachine.initialState) {
          return currentMachine.contextSchema;
        }
      }

      return null;
    }

    function renderTransitions(transitions, instance) {
      const container = document.getElementById('transitions-list');

      if (!transitions || transitions.length === 0) {
        container.innerHTML = `
          <div class="empty-state" style="padding: 20px 0;">
            <div style="font-size: 12px;">No actions available from current state</div>
          </div>`;
        return;
      }

      // Render transitions with parameter forms
      container.innerHTML = transitions.map((t, idx) => {
        const isInterMachine = t.type === 'inter_machine';
        const btnColor = isInterMachine ? '#10b981' : '#3b82f6';
        const icon = isInterMachine ? 'üîó' : '‚Üí';
        const schema = getTransitionSchema(t, instance);

        // Build parameter form if schema exists
        let paramsForm = '';
        if (schema && Object.keys(schema).length > 0) {
          paramsForm = `
            <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px;">
              <div style="font-size: 10px; color: #888; margin-bottom: 8px; text-transform: uppercase;">Parameters</div>
              ${Object.entries(schema).map(([key, field]) => {
                const required = field.required ? '<span style="color: #ef4444;">*</span>' : '';
                const inputType = field.type === 'number' ? 'number' : 'text';
                return `
                  <div style="margin-bottom: 8px;">
                    <label style="display: block; font-size: 11px; color: #aaa; margin-bottom: 4px;">
                      ${field.label || key} ${required}
                    </label>
                    <input type="${inputType}"
                           id="param-${idx}-${key}"
                           placeholder="${field.placeholder || ''}"
                           ${field.required ? 'required' : ''}
                           style="width: 100%; padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--glass-border); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                  </div>`;
              }).join('')}
            </div>`;
        }

        return `
          <div style="margin-bottom: 12px; padding: 12px; background: rgba(255,255,255,0.03); border-radius: 8px; border: 1px solid ${isInterMachine ? 'rgba(16, 185, 129, 0.3)' : 'rgba(59, 130, 246, 0.3)'};">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
              <span style="color: ${btnColor}; font-weight: 600; font-size: 14px;">${icon} ${t.event}</span>
              <span style="color: #666; font-size: 11px;">${t.from} ‚Üí ${t.to}</span>
            </div>
            ${isInterMachine ? `<div style="font-size: 11px; color: #10b981; margin-bottom: 8px;">Creates: ${t.targetMachine}</div>` : ''}
            ${paramsForm}
            <button onclick="sendTransitionEventWithParams('${instance.id}', '${t.event}', ${idx}, ${schema ? 'true' : 'false'})"
              style="width: 100%; margin-top: 10px; padding: 10px; background: ${btnColor}; border: none; border-radius: 6px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
              onmouseover="this.style.opacity='0.85'"
              onmouseout="this.style.opacity='1'">
              Send ${t.event}
            </button>
          </div>`;
      }).join('');
    }

    function clearTransitions() {
      document.getElementById('transitions-list').innerHTML = `
        <div class="empty-state" style="padding: 20px 0;">
          <div style="font-size: 12px;">Select an instance to see transitions</div>
        </div>`;
    }

    // Send event with parameters collected from form
    async function sendTransitionEventWithParams(instanceId, eventType, transitionIdx, hasParams) {
      const component = getCurrentComponent();
      if (!component) return;

      let payload = {};
      const missingRequired = [];

      if (hasParams) {
        // Find the transition to get its schema
        const transition = currentTransitions[transitionIdx];
        const instance = allInstances.find(i => i.id === instanceId);
        const schema = getTransitionSchema(transition, instance);

        if (schema) {
          for (const [key, field] of Object.entries(schema)) {
            const input = document.getElementById(`param-${transitionIdx}-${key}`);
            if (input) {
              let value = input.value?.trim();
              // Convert to number if needed
              if (field.type === 'number' && value) {
                value = parseFloat(value);
              }
              if (value !== '' && value !== null && value !== undefined) {
                payload[key] = value;
                // Reset input style on valid value
                input.style.borderColor = 'var(--glass-border)';
                input.style.boxShadow = 'none';
              } else if (field.required) {
                missingRequired.push(field.label || key);
                // Highlight the input with error style
                input.style.borderColor = '#ef4444';
                input.style.boxShadow = '0 0 4px rgba(239, 68, 68, 0.5)';
              }
            }
          }
        }
      }

      // Validate required fields
      if (missingRequired.length > 0) {
        showToast(`Required fields missing: ${missingRequired.join(', ')}`, 'error');
        return;
      }

      try {
        const res = await fetch(`/api/components/${component.name}/instances/${instanceId}/events`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: eventType, payload })
        });
        if (res.ok) {
          showToast(`Event "${eventType}" sent`, 'success');
        } else {
          const error = await res.json();
          showToast(`Error: ${error.error || 'Failed'}`, 'error');
        }
      } catch (error) {
        showToast('Failed to send event', 'error');
      }
    }

    async function sendTransitionEvent(instanceId, eventType) {
      const component = getCurrentComponent();
      if (!component) return;

      try {
        await fetch(`/api/components/${component.name}/instances/${instanceId}/events`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: eventType, payload: {} })
        });
        showToast(`Event "${eventType}" sent`, 'success');
      } catch (error) {
        showToast('Failed to send event', 'error');
      }
    }

    // Quick event sender from overview with parameters
    // paramKeys: array of all parameter keys
    // requiredKeys: array of required parameter keys (must be filled)
    async function sendQuickEventWithParams(instanceId, eventType, formId, paramKeys, requiredKeys = []) {
      const component = getCurrentComponent();
      if (!component) return;

      // Collect parameters from the inline form
      const payload = {};
      const missingRequired = [];

      if (paramKeys && paramKeys.length > 0) {
        paramKeys.forEach(key => {
          const input = document.getElementById(`${formId}-${key}`);
          const value = input?.value?.trim();

          if (value) {
            // Try to convert to number if it looks like a number
            payload[key] = isNaN(value) ? value : parseFloat(value);
          } else if (requiredKeys.includes(key)) {
            missingRequired.push(key);
            // Highlight the input with error style
            if (input) {
              input.style.borderColor = '#ef4444';
              input.style.boxShadow = '0 0 4px rgba(239, 68, 68, 0.5)';
            }
          }
        });
      }

      // Validate required fields
      if (missingRequired.length > 0) {
        showToast(`Required fields missing: ${missingRequired.join(', ')}`, 'error');
        return;
      }

      try {
        const res = await fetch(`/api/components/${component.name}/instances/${instanceId}/events`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: eventType, payload })
        });
        if (res.ok) {
          showToast(`Event "${eventType}" sent`, 'success');
          // Clear the form inputs after successful send
          paramKeys.forEach(key => {
            const input = document.getElementById(`${formId}-${key}`);
            if (input) input.value = '';
          });
        } else {
          const error = await res.json();
          showToast(`Error: ${error.error || 'Failed'}`, 'error');
        }
      } catch (error) {
        showToast('Failed to send event', 'error');
      }
    }

    // Quick event sender from overview (simple, no params)
    async function sendQuickEvent(instanceId, eventType) {
      return sendQuickEventWithParams(instanceId, eventType, null, []);
    }

    // Stats
    function updateStats() {
      const totalMachines = componentsData.reduce((sum, c) =>
        sum + (c.stateMachines?.length || 0), 0);

      document.getElementById('stat-components').textContent = componentsData.length;
      document.getElementById('stat-machines').textContent = totalMachines;
      document.getElementById('stat-instances').textContent = allInstances.length;
    }

    // Toast notifications
    function showToast(message, type = 'info') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${type} show`;
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }

    // Redraw arrows on window resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (!document.getElementById('component-overview').classList.contains('hidden')) {
          const container = document.getElementById('component-graph');
          const component = getCurrentComponent();
          if (component) {
            // Collect inter-machine links and initial states
            const machines = component.stateMachines || [];
            const interMachineLinks = [];
            const machineInitialStates = {};
            machines.forEach(machine => {
              machineInitialStates[machine.name] = machine.initialState;
              (machine.transitions || []).forEach(transition => {
                if (transition.type === 'inter_machine' && transition.targetMachine) {
                  interMachineLinks.push({
                    fromMachine: machine.name,
                    fromState: transition.from,
                    to: transition.targetMachine,
                    event: transition.event
                  });
                }
              });
            });
            if (interMachineLinks.length > 0) {
              drawInterMachineArrows(container, interMachineLinks, machineInitialStates);
            }
          }
        }
      }, 250);
    });

    // Initialize - instances will be loaded after components_list is received
  </script>
</body>
</html>
